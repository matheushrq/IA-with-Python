# -*- coding: utf-8 -*-
"""Cópia de Puzzle_contagem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ziUQXIXoMI3O450HTv0YAzDCzBKYOs48
"""

class Estado:
  def __init__(self, configuracao):
    self.configuracao = configuracao

  def __str__(self):
    saida = '------------------------------------\n'
    for i in range(0, len(self.configuracao)):
      for j in range(0, len(self.configuracao[0])):
        saida += str(self.configuracao[i][j]) + '\t'
      saida += '\n'
    return saida

class No:
  def __init__(self, altura, custo, estado, pai = None):
    self.pai = pai
    self.altura = altura
    self.custo = custo
    self.estado = estado

  def __str__(self):
    return self.estado

"""Tupla é uma Lista imutável. ... Uma Tupla é definida da mesma forma que uma lista, o que as diferencias, são os caracteres que as delimitam. Uma Lista, tem seus elementos delimitados por colchetes, enquanto que a Tupla, tem seus elementos delimitados por parêntesis."""

import copy

class Util:

  def encontrar_vazio(self, estado, vazio):
    for i in range(0,len(estado.configuracao)):
      for j in range(0, len(estado.configuracao[0])):
        if estado.configuracao[i][j] == vazio:
          return (i,j)
    return -1

  def gerar_novas_coordenadas(self, posicao, max_linha, max_coluna):
    lista = []
    (i, j) = posicao
    if i + 1 < max_linha:
      lista.append( (i+1, j) )
    
    if i - 1 > -1:
      lista.append( (i-1, j) )

    if j + 1 < max_coluna:
      lista.append( (i, j+1) )

    if j - 1 > -1:
      lista.append( (i, j-1))

    return lista

  def troca_posicao(self, estado, posicao1, posicao2):
    aux = estado.configuracao[posicao1[0]][posicao1[1]]
    estado.configuracao[posicao1[0]][posicao1[1]] = estado.configuracao[posicao2[0]][posicao2[1]]
    estado.configuracao[posicao2[0]][posicao2[1]] = aux
    return estado

  def funcao_sucessora(self, estado, vazio):
     novos_estados = []
     posicao_vazia = self.encontrar_vazio(estado, vazio)
     posso_mover_para = self.gerar_novas_coordenadas(posicao_vazia, len(estado.configuracao), len(estado.configuracao[0]))
     for i in range(0, len(posso_mover_para)):
       novo_estado = Estado(copy.deepcopy(estado.configuracao))
       novo_estado = self.troca_posicao(novo_estado, posicao_vazia, posso_mover_para[i])
       novos_estados.append(novo_estado)
     return novos_estados

tabuleiro = Estado(
    [
     [0,1,2],
     [3,4,5],
     [7,8,9]
    ]
)

util = Util()
x = util.funcao_sucessora(tabuleiro, 0)
for i in range(0,len(x)):
  print(x[i])

class Algoritmo:
  def __init__(self, estado_inicial, estado_final, util): #atributos da classe
    self.no_inicial = self.no_raiz(estado_inicial) 
    self.estado_final = estado_final 
    self.util = util 
    self.lista = []
    self.lista.append(self.no_inicial)
    self.estados_criados = {""}

  # a partir do estado inicial recebido cria o nó raiz da árvore de busca
  def no_raiz(self, estado_inicial):
    return No(0, 0, estado_inicial, None) #inicia o algoritmo a partir do estado raiz

  def h(self, estado):
    custo = 0 
    for i in range(0,len(estado.configuracao)): #percorre linha da matriz
      for j in range(0, len(estado.configuracao[i])): #percorre coluna da matriz
        custo += abs(estado.configuracao[i][j] - self.estado_final.configuracao[i][j]) #custo será correspondente à soma dos valores absolutos após obtidos pela diferença do estado que estamos com o estado que desejamos chegar
    return custo #retorna custo total para chegar ao estado final

  def retorna_estados_nao_repetidos(self, conjunto_estados):
    #criar uma nova lista só com estados não repetidos de conjunto_estados (que foi passado de parâmetro)
    estados_nao_repetidos = []
    for i in range(0, len(conjunto_estados)): #percorre cada posição do vetor conjunto_estados
      if not str (conjunto_estados[i].configuracao) in self.estados_criados: #se a posição verificada não estiver dentro de estados criados
        estados_nao_repetidos.append(conjunto_estados[i]) #adiciona no array estados_nao_repetidos
        self.estados_criados.add(str(conjunto_estados[i].configuracao)) #registra no histórico
    return estados_nao_repetidos #retorna os estados não repetidos
    #a cada estado que não for repetido preciso inserir em estados_criados (para evitar visita-los novamente)

  # verifica se o estado passado por parâmetro é igual ao estado final
  def alcancou_estado_final(self, no):
    if no.estado.configuracao == self.estado_final.configuracao: #se a configuração do estado final for alcançada
      return True #retorna true
    else:
      return False

  def no_com_menor_custo(self):
    menor_custo = self.lista[0].custo #lista na posição zero será o de menor custo pois é o estado inicial
    posicao = 0
    for i in range(0, len(self.lista)): #percorre a lista para encontrar o menor custo do vetor
      if self.lista[i].custo < menor_custo: #se o custo do nó da posição i da lista for menor que o menor custo
        menor_custo = self.lista[i].custo #o novo menor custo será atribuído a este elemento // um custo "melhor" foi encontrado
        posicao = i
    return posicao #retorna posição com o melhor valor da lista

  # defina o próximo nó a ser verificado e expandido durante a busca
  def pegar_proximo_no(self):
    posicao_com_menor_custo = self.no_com_menor_custo() #a posição com o menor custo será o novo nó com menor custo
    novo_no = self.lista.pop(posicao_com_menor_custo) #irá retirar a posição antiga para atribuir à nova configuração do nó
    return novo_no #retorna o novo nó com o menor custo

  # cria a estrutura de nó para cada estado na lista "novos_estados"
  def gerar_nos(self, novos_estados, pai):
    novos_estados_formato_no = []
    for i in range(0, len(novos_estados)): #percorre os estados criados
      novos_estados_formato_no.append(No(pai.altura+1, pai.custo+1 + self.h(novos_estados[i]), novos_estados[i], pai)) #para gerar novos estados, será necessário sempre pegar os atributos do estado anterior e somar um, e então, será atribuída a nova configuração de novos estados. Com o self.h, iremos somar o custo total para chegar à configuração do estado final, que é o que, de fato, queremos
    return novos_estados_formato_no #retorna os novos estados

  #percorre a árvore de busca imprimindo o estado
  def imprimir_solucao(self, no_corrente):
    print(no_corrente.estado, end = " ")
    if no_corrente.pai: 
      self.imprimir_solucao(no_corrente.pai) 

  # implementacao de uma busca cega
  def busca_1(self):
    while len(self.lista) > 0: #enquanto o tamanho da lista for mais que 0
      no_corrente = self.pegar_proximo_no() #no_corrente recebe a configuração do novo_no com menor custo
      if not self.alcancou_estado_final(no_corrente): #se o nó recebido não estiver na configuração do estado final
        novos_estados = self.util.funcao_sucessora(no_corrente.estado,0) #novos_estados entra na função sucessora
        novos_estados = self.retorna_estados_nao_repetidos(novos_estados) #novos_estados passa a receber a configuração de estados não repetidos
        if len(novos_estados) > 0: #enquanto o tamanho do vetor 'novos_estados' for mais que 0
          novos_NOS = self.gerar_nos(novos_estados, no_corrente) #novos nós serão gerados com as configurações
          self.lista.extend(novos_NOS)       
      else:
        self.imprimir_solucao(no_corrente) 
        return

historico = {""}

tabuleiro1 = [
              [1,2,3],
              [4,5,6],
              [7,8,0] 
             ]

tabuleiro2 =  [
              [0,2,3],
              [4,5,6],
              [7,8,1] 
             ]       

estado1 = Estado(tabuleiro1)
estado2 = Estado(tabuleiro2)

novos_estados = [estado1, estado2, estado1, estado1, estado2]

procurando =  [
              [1,2,3],
              [4,5,6],
              [7,8,0] 
             ]

for i in range(0, len(novos_estados)):
  if str(novos_estados[i].configuracao) in historico:
    print("ta la dentro")
  else:
    print("não ta la dentro")
    historico.add(str(novos_estados[i].configuracao))

print(historico)

util = Util()
tabuleiro_inicial = Estado(
    [
     [2,8,4],
     [1,0,6],
     [5,3,7]
    ]
)

tabuleiro_final = Estado(
    [
     [1,2,3],
     [4,5,6],
     [7,8,0]
    ]
)
algoritmo = Algoritmo(tabuleiro_inicial,tabuleiro_final, util)

# executa o algoritmo de busca 1 - Descubra de que tipo de busca se trata
algoritmo.busca_1()

"""0.   Comentar a classe UTIL (Função Sucessora)
1.   O que é o algoritmo A* e qual a sua diferença para uma busca cega?
2.   Quais alterações deveriam ser feitas no algoritmo acima para aplicar a busca A*?
3.  Descreva uma função heurística para o puzzle.
4.  Altere as partes necessários do algoritmo para transforma-lo em uma busca A*.
"""