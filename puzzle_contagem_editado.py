# -*- coding: utf-8 -*-
"""Puzzle_contagem_editado.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nYt9TVErxesc5cD2JGXbKCNd-lUfFff2
"""

class Estado:
  def __init__(self, configuracao):
    self.configuracao = configuracao

  def __str__(self):
    saida = '------------------------------------\n'
    for i in range(0, len(self.configuracao)):
      for j in range(0, len(self.configuracao[0])):
        saida += str(self.configuracao[i][j]) + '\t'
      saida += '\n'
    return saida

class No:
  def __init__(self, altura, custo, estado, pai = None):
    self.pai = pai
    self.altura = altura
    self.custo = custo
    self.estado = estado

  def __str__(self):
    return self.estado

"""Tupla é uma Lista imutável. ... Uma Tupla é definida da mesma forma que uma lista, o que as diferencias, são os caracteres que as delimitam. Uma Lista, tem seus elementos delimitados por colchetes, enquanto que a Tupla, tem seus elementos delimitados por parêntesis."""

import copy

class Util:

  def encontrar_vazio(self, estado, vazio):
    for i in range(0,len(estado.configuracao)):
      for j in range(0, len(estado.configuracao[0])): #percorrendo matriz do puzzle para encontrar a posição vazia
        if estado.configuracao[i][j] == vazio: #após percorrer e encontrar, a configuração do estado é atribuída à posição que está vazia
          return (i,j)
    return -1

  def gerar_novas_coordenadas(self, posicao, max_linha, max_coluna):
    lista = []
    (i, j) = posicao
    if i + 1 < max_linha:
      lista.append( (i+1, j) ) #posição vazia é movida uma posição para a direita
    
    if i - 1 > -1:
      lista.append( (i-1, j) ) #posição vazia é movida uma posição para a esquerda

    if j + 1 < max_coluna:
      lista.append( (i, j+1) ) #posição vazia é movida uma posição para cima

    if j - 1 > -1:
      lista.append( (i, j-1)) #posição vazia é movida uma posição para baixo

    return lista #retorna estado obtido

  def troca_posicao(self, estado, posicao1, posicao2):
    aux = estado.configuracao[posicao1[0]][posicao1[1]] #estado de onde partirá a "base" para realizar novas configurações
    estado.configuracao[posicao1[0]][posicao1[1]] = estado.configuracao[posicao2[0]][posicao2[1]] #configuração do estado passa a ser a configuração gerada após mudança de posições do puzze
    estado.configuracao[posicao2[0]][posicao2[1]] = aux #nova configuração salva
    return estado

  def funcao_sucessora(self, estado, vazio):
     novos_estados = []
     posicao_vazia = self.encontrar_vazio(estado, vazio) #verifica e atribui a posição vazia
     posso_mover_para = self.gerar_novas_coordenadas(posicao_vazia, len(estado.configuracao), len(estado.configuracao[0])) #variável que recebe novas configurações após verificação e novas possíveis combinações
     for i in range(0, len(posso_mover_para)):
       novo_estado = Estado(copy.deepcopy(estado.configuracao)) #recopia as configurações obtidas
       novo_estado = self.troca_posicao(novo_estado, posicao_vazia, posso_mover_para[i]) #gera nova configuração após movimentações obtidas
       novos_estados.append(novo_estado) #salva as novas configurações obtidas
     return novos_estados

tabuleiro = Estado(
    [
     [0,1,2],
     [3,4,5],
     [7,8,9]
    ]
)

util = Util()
x = util.funcao_sucessora(tabuleiro, 0)
for i in range(0,len(x)):
  print(x[i])

class Algoritmo:
  def __init__(self, estado_inicial, estado_final, util):
    self.no_inicial = self.no_raiz(estado_inicial) 
    self.estado_final = estado_final 
    self.util = util 
    self.lista = []
    self.lista.append(self.no_inicial)

  # a partir do estado inicial recebido cria o nó raiz da árvore de busca
  def no_raiz(self, estado_inicial):
    return No(0, 0, estado_inicial, None)

  # verifica se o estado passado por parâmetro é igual ao estado final
  def alcancou_estado_final(self, no):
    if no.estado.configuracao == self.estado_final.configuracao:
      return True
    else:
      return False

  # defina o próximo nó a ser verificado e expandido durante a busca
  def pegar_proximo_no(self):
    novo_no = self.lista[0]    
    if len(self.lista) > 1:
      self.lista = self.lista[1:]
    else:
      self.lista = []    
    return novo_no

  # cria a estrutura de nó para cada estado na lista "novos_estados"
  def gerar_nos(self, novos_estados, pai):
    novos_estados_formato_no = []
    for i in range(0, len(novos_estados)):
      novos_estados_formato_no.append(No(pai.altura+1, pai.custo+1+h(novos_estados[i]), novos_estados[i], pai))
    return novos_estados_formato_no

  #percorre a árvore de busca imprimindo o estado
  def imprimir_solucao(self, no_corrente):
    print(no_corrente.estado, end = " ")
    if no_corrente.pai:      
      self.imprimir_solucao(no_corrente.pai)

  # implementacao de uma busca cega
  def busca_1(self):
    while len(self.lista) > 0:
      no_corrente = self.pegar_proximo_no()
      if not self.alcancou_estado_final(no_corrente):
        novos_estados = self.util.funcao_sucessora(no_corrente.estado,0)
        if len(novos_estados) > 0:
          novos_NOS = self.gerar_nos(novos_estados, no_corrente)
          self.lista.extend(novos_NOS)          
      else:
        self.imprimir_solucao(no_corrente)
        return

util = Util()
tabuleiro_inicial = Estado(
    [
     [2,0,3],
     [1,5,6],
     [4,7,8]
    ]
)

tabuleiro_final = Estado(
    [
     [1,2,3],
     [4,5,6],
     [7,8,0]
    ]
)
algoritmo = Algoritmo(tabuleiro_inicial,tabuleiro_final, util)

# executa o algoritmo de busca 1 - Descubra de que tipo de busca se trata
algoritmo.busca_1()

"""0.   Comentar a classe UTIL (Função Sucessora)
1.   O que é o algoritmo A* e qual a sua diferença para uma busca cega? O Algoritmo A* verifica configurações sucessoras, e após analisar configurações já realizadas/obtidas, ele monta um caminho que permite escolher o estado mais próximo.
2.   Quais alterações deveriam ser feitas no algoritmo acima para aplicar a busca A*? Alterar o if para verificar se certa configuração do estado já foi aplicada, e se sim, não verificar e procurar o melhor caminho para chegar ao estado final.
3.  Descreva uma função heurística para o puzzle. Irá realizar uma "comparação" do estado de onde iremos partir com o estado que desejamos chegar e calcula o custo necessário para chegar àquela configuração.
4.  Altere as partes necessários do algoritmo para transforma-lo em uma busca A*.
"""